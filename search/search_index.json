{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ezp","text":"<p><code>ezp</code> is a lightweight C++ wrapper for selected ScaLAPACK solvers for linear systems.</p>"},{"location":"#dependency","title":"Dependency","text":"<p>The <code>ezp</code> library is header only. The following drivers are needed.</p> <ol> <li>an implementation of <code>LAPACK</code> and <code>BLAS</code>, such as <code>OpenBLAS</code>, <code>MKL</code>, etc.</li> <li>an implementation of <code>ScaLAPACK</code></li> <li>an implementation of <code>MPI</code>, such as <code>OpenMPI</code>, <code>MPICH</code>, etc.</li> </ol>"},{"location":"#example","title":"Example","text":"<p>It is assumed that the root node (rank 0) prepares the left hand side \\(\\(A\\)\\) and right hand side \\(\\(B\\)\\). The solvers distrbute the matrices to available processes and solve the system, return the solution back to the master node.</p> <p>The solvers are designed in such a way that all <code>BLACS</code> and <code>ScaLAPACK</code> details are hidden. One shall prepare the matrices (on the root node) and call the solver. The following is a typical example. It highly resembles the sequential version of how one would typically solve a linear system.</p> C++<pre><code>#include &lt;ezp/pgesv.hpp&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n\nusing namespace ezp;\n\nint main() {\n    // get the current blacs environment\n    const auto rank = get_env&lt;int&gt;().rank();\n\n    constexpr auto N = 6, NRHS = 2;\n\n    // storage for the matrices A and B\n    std::vector&lt;double&gt; A, B;\n\n    if(0 == rank) {\n        // the matrices are only initialized on the root process\n        A.resize(N * N, 0.);\n        B.resize(N * NRHS, 1.);\n\n        // helper functor to convert 2D indices to 1D indices\n        const auto IDX = par_dgesv&lt;int&gt;::indexer{N};\n\n        for(auto I = 0; I &lt; N; ++I) A[IDX(I, I)] = static_cast&lt;double&gt;(I);\n    }\n\n    // create a parallel solver\n    // it takes the number of rows and columns of the process grid as arguments\n    // or let the library automatically determine as follows\n    // need to wrap the data in full_mat objects\n    // it requires the number of rows and columns of the matrix, and a pointer to the data\n    // on non-root processes, the data pointer is nullptr as the vector is empty\n    // par_dgesv&lt;int&gt;().solve(full_mat{N, N, A.data()}, full_mat{N, NRHS, B.data()});\n    par_dgesv&lt;int&gt;().solve({N, N, A.data()}, {N, NRHS, B.data()});\n\n    if(0 == rank) {\n        std::cout &lt;&lt; std::setprecision(10) &lt;&lt; \"Solution:\\n\";\n        for(auto i = 0; i &lt; B.size(); ++i) std::cout &lt;&lt; B[i] &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>"}]}